import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { corsHeaders } from "../_shared/cors.ts";

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  const json = (body: unknown, status = 200) =>
    new Response(JSON.stringify(body), {
      status,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });

  try {
    // 1. Auth check
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) return json({ error: "Non authentifié" }, 401);

    const anonClient = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_ANON_KEY")!,
      { global: { headers: { Authorization: authHeader } } },
    );
    const { data: { user } } = await anonClient.auth.getUser();
    if (!user) return json({ error: "Non authentifié" }, 401);

    // 2. Parse body
    const { workspace_id, email, role } = await req.json();
    if (!workspace_id || !email) {
      return json({ error: "workspace_id et email sont requis" }, 400);
    }

    const inviteRole = role || "editor";
    if (!["editor", "viewer"].includes(inviteRole)) {
      return json({ error: "Rôle invalide. Valeurs acceptées : editor, viewer" }, 400);
    }

    // 3. Service client for privileged checks
    const sb = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!,
    );

    // 4. Check caller is owner or manager of the workspace
    const { data: membership } = await sb
      .from("workspace_members")
      .select("role")
      .eq("workspace_id", workspace_id)
      .eq("user_id", user.id)
      .maybeSingle();

    if (!membership || !["owner", "manager"].includes(membership.role)) {
      return json({ error: "Accès refusé. Tu dois être owner ou manager de cet espace." }, 403);
    }

    // 5. Check if email is already a member
    // First find user by email
    const { data: existingUsers } = await sb.auth.admin.listUsers();
    const targetUser = existingUsers?.users?.find(
      (u) => u.email?.toLowerCase() === email.toLowerCase(),
    );

    if (targetUser) {
      const { data: alreadyMember } = await sb
        .from("workspace_members")
        .select("id")
        .eq("workspace_id", workspace_id)
        .eq("user_id", targetUser.id)
        .maybeSingle();

      if (alreadyMember) {
        return json({ error: "Cet email est déjà membre de cet espace." }, 409);
      }
    }

    // 6. Check if invitation already exists (pending)
    const { data: existingInvite } = await sb
      .from("workspace_invitations")
      .select("id")
      .eq("workspace_id", workspace_id)
      .eq("email", email.toLowerCase())
      .is("accepted_at", null)
      .gt("expires_at", new Date().toISOString())
      .maybeSingle();

    if (existingInvite) {
      return json({ error: "Une invitation est déjà en attente pour cet email." }, 409);
    }

    // 7. Create invitation (token is auto-generated by DB default)
    const { data: invitation, error: insertErr } = await sb
      .from("workspace_invitations")
      .insert({
        workspace_id,
        email: email.toLowerCase(),
        role: inviteRole,
        invited_by: user.id,
      })
      .select("id, token")
      .single();

    if (insertErr) {
      console.error("Insert error:", insertErr);
      if (insertErr.code === "23505") {
        return json({ error: "Une invitation existe déjà pour cet email dans cet espace." }, 409);
      }
      throw insertErr;
    }

    // 8. Build invite URL
    const origin = req.headers.get("origin") || "https://nowadaysagency.lovable.app";
    const inviteUrl = `${origin}/invite/${invitation.token}`;

    return json({
      success: true,
      token: invitation.token,
      invite_url: inviteUrl,
      invitation_id: invitation.id,
    });
  } catch (e) {
    console.error("invite-to-workspace error:", e);
    return json(
      { error: e instanceof Error ? e.message : "Erreur inconnue" },
      500,
    );
  }
});
